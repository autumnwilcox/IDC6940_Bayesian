---
title: "Bayesian Logistic Regression for Diabetes Risk (NHANES 2013–2014)"
subtitle: "Capstone Report"
author:
  - "Namita Mishra"
  - "Autumn Wilcox"
advisor: "Dr. Ashraf Cohen"
date: '`r Sys.Date()`'
format:
  html:
    code-fold: true
course: Capstone Projects in Data Science
bibliography: references.bib
self-contained: true
execute:
  warning: false
  message: false
editor:
  markdown:
    wrap: 72
---

Slides: [slides.html](slides.html){target="_blank"} (Edit `slides.qmd`.)

## Introduction

Diabetes mellitus (DM) is a major public health challenge, and identifying key risk factors—such as obesity, age, sex, and race/ethnicity—is essential for prevention and targeted intervention. Logistic regression is widely used to estimate associations between such risk factors and binary outcomes, including the presence or absence of diabetes. However, classical maximum likelihood estimation (MLE) can yield unstable results in small samples or in the presence of missing data, quasi-separation, or complete separation. Moreover, healthcare data (e.g., DNA sequences, imaging, patient-reported outcomes, electronic health records, and longitudinal health measurements) are often complex, making standard analytical approaches insufficient [@zeger2020].

Bayesian hierarchical models, implemented via Markov Chain Monte Carlo (MCMC), provide a framework that integrates prior knowledge and accounts for hierarchical data structures. These models have been successfully applied in predicting patient health status across diseases such as pneumonia, prostate cancer, and mental disorders [@zeger2020]. Compared to frequentist approaches, Bayesian inference naturally quantifies uncertainty and accommodates complex covariate structures, though it remains limited by parametric assumptions.

Recent work has extended Bayesian methods to disease diagnostics. For example, Bayesian inference has been used to evaluate diagnostic test data from the National Health and Nutrition Examination Survey (NHANES), comparing parametric and nonparametric approaches. These methods provide posterior probabilities that improve disease classification, especially where conventional dichotomous thresholds fail to capture heterogeneity in populations [@chatzimichail2023]. Similarly, Bayesian clinical reasoning models have been applied to cardiovascular and metabolic risk prediction, emulating clinician decision-making by incorporating demographic, metabolic, and conventional risk factors [@liu2013].

Bayesian regression also addresses methodological challenges such as missing data. Multiple imputation combined with Bayesian modeling has been applied in clinical research, generating robust estimates under assumptions of missing at random (MAR), missing not at random (MNAR), or missing completely at random (MCAR) [@austin2021]. These applications highlight the versatility of Bayesian approaches in healthcare, particularly when traditional models are undermined by data limitations.

The broader Bayesian literature emphasizes the importance of prior specification, model checking, and variable selection. Vande Schoot et al. highlight the role of informative, weakly informative, and diffuse priors, noting that prior elicitation can draw from experts, data-based approaches, or maximum likelihood estimates [@vandeschoot2021]. Priors not only regularize estimates but also improve performance in small samples. Tutorials demonstrate how packages such as brms and blavaan in R, combined with MCMC, allow estimation of posterior distributions and facilitate empirical Bayesian analysis [@klauenberg2015].

In meta-analytic settings, Bayesian hierarchical regression has been used to augment data with results from prior studies. This approach incorporates both exchangeable and unexchangeable predictors, enabling explicit testing of heterogeneity across studies [@deleeuw2012]. Other works extend Bayesian methods to psychology and neuroscience (e.g., EEG studies [@baldwin2017]), intuitive reasoning frameworks [@kruschke2017], and Bayesian deep learning in healthcare applications such as imaging [@abdullah2022].

## Aim 

**Our Aim** is to estimate the association between BMI, age, sex, and race/ethnicity and doctor-diagnosed diabetes among adults (≥20 years) in NHANES 2013–2014, and to evaluate whether a Bayesian approach provides more stable inference than frequentist baselines under missingness and potential separation.

## Data & Preparation

- **Source:** NHANES (CDC/NCHS) 2013–2014 [@nchs1999].
- **Files:** `BMX_H` (body measures), `DEMO_H` (demographics),
  `DIQ_H` (diabetes questionnaire).
- **Population:** **Adults aged ≥20 years**.
- **Outcome:** `DIQ010` — *“Has a doctor told you that you have diabetes?”* (1=Yes, 2=No; 7/9 treated as NA). We construct `diabetes_dx` ∈ {0,1}.
- **Predictors:**
  - `BMXBMI` (continuous BMI, kg/m²). Optional adult categories if needed.
  - `RIDAGEYR` (age, continuous).
  - `RIAGENDR` (sex: male/female).
  - `RIDRETH1` (race/ethnicity: 5-level categorical).
- **Survey Design Variables:** `WTMEC2YR` (exam weight), `SDMVPSU`, `SDMVSTRA`.

```{r}
# ---- Load merged data that DEFINITELY includes DIQ010 ----
library(tidyverse)

if (!file.exists("data/merged_2013_2014.rds")) {
  message("Rebuilding merged_2013_2014.rds ...")
  source("R/data_prep.R")
}
merged_data <- readRDS("data/merged_2013_2014.rds")

# Hard stop if DIQ010 isn't usable
if (!("DIQ010" %in% names(merged_data))) {
  stop("DIQ010 missing in merged_data (R/data_prep.R).")
}
if (sum(merged_data$DIQ010 %in% c(1,2), na.rm = TRUE) == 0) {
  stop("DIQ010 has no 1/2 values in merged_data. Re-run R/data_prep.R and check console counts.")
}

# ---- Packages & plotting theme ----
library(tidyverse)
library(knitr)
library(survey)
library(ggplot2)
library(viridis)
library(bayesplot)

theme_set(theme_minimal(base_size = 13))
custom_colors <- viridis(3, option = "D")
color_scheme_set("viridis")

# ---- Load or rebuild merged data (DEMO_H + BMX_H + DIQ_H) ----
if (!file.exists("data/merged_2013_2014.rds")) {
  message("Building merged_2013_2014.rds via R/data_prep.R ...")
  source("R/data_prep.R")
}

merged_data <- readRDS("data/merged_2013_2014.rds")

# ---- Robust coercion for NHANES-coded fields (handles 'Yes/No' labels) ----
to_num <- function(x) {
  if (is.numeric(x)) return(x)
  xc <- as.character(x)
  # Try numeric parsing first (handles "1 Yes" or " 2 No")
  n <- suppressWarnings(readr::parse_number(xc))
  # If mostly NA after parse, map common text labels explicitly
  if (mean(is.na(n)) > 0.80) {
    xlow <- tolower(trimws(xc))
    n <- dplyr::case_when(
      xlow %in% c("1","yes","yes, told") ~ 1,
      xlow %in% c("2","no","no, not told") ~ 2,
      xlow %in% c("3","borderline") ~ 3,
      xlow %in% c("7","refused") ~ 7,
      xlow %in% c("9","don't know","dont know","unknown") ~ 9,
      TRUE ~ NA_real_
    )
  }
  as.numeric(n)
}

need_cols <- c("DIQ010","DIQ050","BMXBMI","RIDAGEYR","RIAGENDR",
               "RIDRETH1","SDMVPSU","SDMVSTRA","WTMEC2YR")
missing_cols <- setdiff(need_cols, names(merged_data))
if (length(missing_cols)) {
  stop("Merged data is missing columns: ", paste(missing_cols, collapse = ", "))
}

# Keep a diagnostic copy (before coercion) for helpful error messages
diag_DIQ010 <- merged_data$DIQ010

merged_data <- merged_data %>%
  mutate(
    DIQ010   = to_num(DIQ010),
    DIQ050   = to_num(if (!"DIQ050" %in% names(.)) NA_real_ else DIQ050),
    BMXBMI   = to_num(BMXBMI),
    RIDAGEYR = to_num(RIDAGEYR),
    RIAGENDR = to_num(RIAGENDR),
    RIDRETH1 = to_num(RIDRETH1),
    SDMVPSU  = to_num(SDMVPSU),
    SDMVSTRA = to_num(SDMVSTRA),
    WTMEC2YR = to_num(WTMEC2YR)
  )

# ---- Validate DIQ010 really contains 1/2 after coercion ----
cat("DIQ010 (after coercion) counts:\n")
print(table(merged_data$DIQ010, useNA = "ifany"))

if (sum(merged_data$DIQ010 %in% c(1, 2), na.rm = TRUE) == 0) {
  cat("\nFirst 10 unique raw DIQ010 values found BEFORE coercion:\n")
  print(utils::head(unique(as.character(diag_DIQ010)), 10))
  stop("DIQ010 has no 1/2 values after coercion. ",
       "Inspect DIQ_H in R/data_prep.R (ensure DIQ010 is selected) ",
       "and re-run source('R/data_prep.R').")
}

# Optional: quick peek
# knitr::kable(head(merged_data))
```

### Basic Exploration 

```{r}
# ---------------- Basic Exploration (adults) ----------------

# Keep adults only and build analysis variables
adult <- merged_data %>%
  dplyr::filter(RIDAGEYR >= 20) %>%
  dplyr::transmute(
    # --- keep survey design variables so svydesign() can see them ---
    SDMVPSU, SDMVSTRA, WTMEC2YR,

    # --- outcome: DIQ010 (1 yes, 2 no; 3/7/9 -> NA) ---
    diabetes_dx = dplyr::case_when(
      DIQ010 == 1 ~ 1,
      DIQ010 == 2 ~ 0,
      DIQ010 %in% c(3, 7, 9) ~ NA_real_,
      TRUE ~ NA_real_
    ),

    # --- predictors (raw) ---
    bmi  = BMXBMI,
    age  = RIDAGEYR,

    # sex (1=Male, 2=Female)
    sex  = forcats::fct_recode(factor(RIAGENDR), Male = "1", Female = "2"),

    # race (5-level)
    race = forcats::fct_recode(
      factor(RIDRETH1),
      "Mexican American" = "1",
      "Other Hispanic"   = "2",
      "NH White"         = "3",
      "NH Black"         = "4",
      "Other/Multi"      = "5"
    ),

    # keep DIQ050 so we can safely reference it (may be absent/NA in some rows)
    DIQ050 = DIQ050
  ) %>%
  # standardize continuous predictors
  dplyr::mutate(
    age_c = as.numeric(scale(age)),
    bmi_c = as.numeric(scale(bmi)),
    bmi_cat = cut(
      bmi,
      breaks = c(-Inf, 18.5, 25, 30, 35, 40, Inf),
      labels = c("<18.5","18.5–<25","25–<30","30–<35","35–<40","≥40"),
      right = FALSE
    )
  ) %>%
  # adjust outcome: if female & DIQ050==1 ("only when pregnant"), set to 0 (not diabetes)
  dplyr::mutate(
    diabetes_dx = ifelse(sex == "Female" & !is.na(DIQ050) & DIQ050 == 1, 0, diabetes_dx)
  )

# Make NH White the reference level for race (clearer interpretation)
adult <- adult %>%
  dplyr::mutate(
    race = forcats::fct_relevel(race, "NH White")
  )

# --- sanity checks ---
cat("Adults n =", nrow(adult), "\n")
cat("Non-missing diabetes_dx =", sum(!is.na(adult$diabetes_dx)), "\n")
print(table(adult$diabetes_dx, useNA = "ifany"))
print(table(adult$sex, useNA = "ifany"))
print(table(adult$race, useNA = "ifany"))

if (sum(!is.na(adult$diabetes_dx)) == 0) {
  stop("Too few non-missing outcomes for modeling (n = 0). Check DIQ010 upstream.")
}

# (optional plots omitted for brevity)

# save for downstream
if (!dir.exists("data")) dir.create("data", recursive = TRUE)
saveRDS(adult, "data/adult_cleaned_2013_2014.rds")
```

### Survey Design

``` {r}
# ---------------- Survey Design ----------------
# Use exam weights because BMI (BMXBMI) is an MEC variable
nhanes_design_adult <- survey::svydesign(
  id = ~SDMVPSU,
  strata = ~SDMVSTRA,
  weights = ~WTMEC2YR,
  nest = TRUE,
  data = adult
)

# quick weighted checks
survey::svymean(~age, nhanes_design_adult, na.rm = TRUE)
survey::svymean(~diabetes_dx, nhanes_design_adult, na.rm = TRUE)
```

## Methods

We applied four complementary approaches to the NHANES 2013–2014 adult dataset to estimate the association between BMI, age, sex, and race/ethnicity and doctor-diagnosed diabetes (`DIQ010`). Continuous predictors (age, BMI) were standardized (mean = 0, SD = 1) to improve model convergence and interpretability. Analyses were limited to adults aged ≥20 years and accounted for NHANES’s complex sampling design using weights (`WTMEC2YR`), strata (`SDMVSTRA`), and primary sampling units (`SDMVPSU`).

1. **Frequentist Logistic Regression (MLE):**  
   - Baseline model predicting doctor-diagnosed diabetes (`DIQ010`) from standardized BMI (`bmi_c`), age (`age_c`), sex, and race/ethnicity.  
   - Complete-case, **survey-weighted logistic regression** implemented with the `survey` package in R.  
   - Provided population-weighted odds ratios and 95% confidence intervals.  
   - Limitation: listwise deletion of missing predictors may reduce precision and introduce bias.

2. **Firth Penalized Logistic Regression:**  
   - Frequentist alternative using the **Jeffreys prior penalty** for small-sample bias reduction [@dangelo2025].  
   - Produces finite coefficients even under quasi- or complete-separation conditions.  
   - Used as a sensitivity analysis to assess stability of frequentist results.  
   - Does not yield posterior distributions or full uncertainty quantification like Bayesian models.

3. **Multiple Imputation by Chained Equations (MICE):**  
   - Applied to **predictors only** (not the diabetes outcome) to address missing data and retain sample size [@vanbuuren2012].  
   - Predictive mean matching (`pmm`) for continuous variables; polytomous logistic regression (`polyreg`) for categorical predictors.  
   - Five imputed datasets analyzed with logistic regression; results combined using **Rubin’s rules**.  
   - Survey design variables (`WTMEC2YR`, `SDMVPSU`, `SDMVSTRA`) included as auxiliaries, not imputed.

4. **Bayesian Logistic Regression:**  
   - Modeled `DIQ010` as a function of standardized BMI (`bmi_c`), age (`age_c`), sex, and race/ethnicity using `brms`.  
   - Priors: weakly informative Normal(0, 2.5) for coefficients and Student-t(3, 0, 10) for the intercept [@gelman2008].  
   - Four chains × 2000 iterations (50% warm-up), `adapt_delta = 0.95`.  
   - **Normalized survey weights** (`WTMEC2YR` scaled to mean 1) used as importance weights to approximate complex sampling.  
   - Diagnostics: **R̂ < 1.01**, effective sample sizes, trace plots, and **posterior predictive checks (`pp_check`)**.  
   - Note: `brms` weights approximate but do not fully model NHANES design (no strata/PSU in likelihood).

## Modeling

```{r}
## Modeling

library(broom)
library(mice)
library(brms)
library(posterior)
library(bayesplot)
library(knitr)

# --- Guardrails for modeling ---
n_outcome <- sum(!is.na(adult$diabetes_dx))
if (n_outcome == 0) stop("Too few non-missing outcomes for modeling. n = 0")

# Ensure factors and >=2 observed levels among complete outcomes
adult <- adult %>%
  dplyr::mutate(
    sex  = if (!is.factor(sex))  factor(sex)  else sex,
    race = if (!is.factor(race)) factor(race) else race
  )

if (nlevels(droplevels(adult$sex[!is.na(adult$diabetes_dx)]))  < 2)
  stop("sex has <2 observed levels after filtering; check data availability.")
if (nlevels(droplevels(adult$race[!is.na(adult$diabetes_dx)])) < 2)
  stop("race has <2 observed levels after filtering; check Data Prep.")

# ------------------------- 1) Survey-weighted complete-case -------------------------
# Build a logical filter on the original adult data (same length as design$data)
keep_cc <- with(
  adult,
  !is.na(diabetes_dx) & !is.na(age_c) & !is.na(bmi_c) &
  !is.na(sex) & !is.na(race)
)

# Subset the survey design using the logical vector (same length as original)
des_cc <- subset(nhanes_design_adult, keep_cc)

# Corresponding complete-case data (optional)
cc <- adult[keep_cc, ] |> droplevels()
cat("\nComplete-case N for survey-weighted model:", nrow(cc), "\n")
print(table(cc$race))

form_cc <- diabetes_dx ~ age_c + bmi_c + sex + race
svy_fit <- survey::svyglm(formula = form_cc, design = des_cc, family = quasibinomial())
summary(svy_fit)

# Survey-weighted OR table (no intercept)
svy_or <- broom::tidy(svy_fit, conf.int = TRUE) %>%
  dplyr::mutate(OR = exp(estimate), LCL = exp(conf.low), UCL = exp(conf.high)) %>%
  dplyr::select(term, OR, LCL, UCL, p.value) %>%
  dplyr::filter(term != "(Intercept)")
knitr::kable(svy_or, caption = "Survey-weighted odds ratios (per 1 SD)")

# ------------------------- 2) Multiple Imputation (predictors only) -------------------------
mi_dat <- adult %>%
  dplyr::select(diabetes_dx, age, bmi, sex, race, WTMEC2YR, SDMVPSU, SDMVSTRA)

meth <- mice::make.method(mi_dat)
pred <- mice::make.predictorMatrix(mi_dat)

# Do not impute outcome
meth["diabetes_dx"] <- ""
pred["diabetes_dx", ] <- 0
pred[,"diabetes_dx"] <- 1

# Imputation methods
meth["age"]  <- "norm"
meth["bmi"]  <- "pmm"
meth["sex"]  <- "polyreg"
meth["race"] <- "polyreg"

# Survey design vars as auxiliaries only
meth[c("WTMEC2YR","SDMVPSU","SDMVSTRA")] <- ""
pred[, c("WTMEC2YR","SDMVPSU","SDMVSTRA")] <- 1

imp <- mice::mice(mi_dat, m = 5, method = meth, predictorMatrix = pred, seed = 123)

fit_mi <- with(imp, {
  age_c <- as.numeric(scale(age))
  bmi_c <- as.numeric(scale(bmi))
  glm(diabetes_dx ~ age_c + bmi_c + sex + race, family = binomial())
})
pool_mi <- pool(fit_mi)
summary(pool_mi)

mi_or <- summary(pool_mi, conf.int = TRUE, exponentiate = TRUE) %>%
  dplyr::rename(
    term = term, OR = estimate, LCL = `2.5 %`, UCL = `97.5 %`, p.value = p.value
  ) %>%
  dplyr::filter(term != "(Intercept)")
knitr::kable(mi_or, caption = "MI pooled odds ratios (per 1 SD)")

# ------------------------- 3) Bayesian Logistic Regression (formula weights) -------------------------
adult_imp1 <- complete(imp, 1) %>%
  dplyr::mutate(
    age_c  = as.numeric(scale(age)),
    bmi_c  = as.numeric(scale(bmi)),
    wt_norm = WTMEC2YR / mean(WTMEC2YR, na.rm = TRUE),
    # ensure factor refs match survey/MICE:
    race = forcats::fct_relevel(race, "NH White"),
    sex  = forcats::fct_relevel(sex,  "Male")
  ) %>%
  dplyr::filter(!is.na(diabetes_dx), !is.na(age_c), !is.na(bmi_c),
                !is.na(sex), !is.na(race)) %>%
  droplevels()

stopifnot(all(is.finite(adult_imp1$wt_norm)))

priors <- c(
  set_prior("normal(0, 2.5)", class = "b"),
  set_prior("student_t(3, 0, 10)", class = "Intercept")
)

bayes_fit <- brm(
  formula = diabetes_dx | weights(wt_norm) ~ age_c + bmi_c + sex + race,
  data    = adult_imp1,
  family  = bernoulli(link = "logit"),
  prior   = priors,
  chains  = 4, iter = 2000, seed = 123,
  control = list(adapt_delta = 0.95),
  refresh = 0   # quiet Stan output
)

summary(bayes_fit)

# Posterior ORs (drop intercept, clean labels)
bayes_or <- posterior_summary(bayes_fit, pars = "^b_") %>%
  as.data.frame() %>%
  tibble::rownames_to_column("raw") %>%
  dplyr::mutate(
    term = gsub("^b_", "", raw),
    term = gsub("race", "race:", term),
    term = gsub("sex",  "sex:",  term),
    term = gsub("OtherDMulti", "Other/Multi", term),
    term = gsub("OtherHispanic", "Other Hispanic", term),
    OR   = exp(Estimate),
    LCL  = exp(Q2.5),
    UCL  = exp(Q97.5)
  ) %>%
  dplyr::select(term, OR, LCL, UCL) %>%
  dplyr::filter(term != "Intercept")

knitr::kable(
  bayes_or %>%
    dplyr::mutate(dplyr::across(c(OR,LCL,UCL), ~round(.x, 2))),
  digits = 2,
  caption = "Bayesian posterior odds ratios (95% CrI) — reference: NH White (race), Male (sex)"
)

# ------------------------- Save artifacts (optional) -------------------------
if (!dir.exists("outputs")) dir.create("outputs", recursive = TRUE)
saveRDS(svy_fit,   "outputs/svy_fit.rds")
saveRDS(pool_mi,   "outputs/pool_mi.rds")
saveRDS(bayes_fit, "outputs/bayes_fit.rds")
saveRDS(svy_or,    "outputs/survey_OR_table.rds")
saveRDS(mi_or,     "outputs/mi_OR_table.rds")
saveRDS(bayes_or,  "outputs/bayes_OR_table.rds")
```

## Results  

```{r}
# ---- Build compact results table (BMI & Age only) ----
library(dplyr); library(tidyr); library(knitr); library(stringr)

# pretty "OR (LCL–UCL)" string
fmt_or <- function(or, lcl, ucl, digits = 2) {
  paste0(
    formatC(or,  format = "f", digits = digits), " (",
    formatC(lcl, format = "f", digits = digits), "–",
    formatC(ucl, format = "f", digits = digits), ")"
  )
}

# guardrails: require these to exist from Modeling
stopifnot(exists("svy_or"), exists("mi_or"), exists("bayes_or"))
for (nm in c("svy_or","mi_or","bayes_or")) {
  if (!all(c("term","OR","LCL","UCL") %in% names(get(nm)))) {
    stop(nm, " must have columns: term, OR, LCL, UCL")
  }
}

svy_tbl   <- svy_or   %>% mutate(Model = "Survey-weighted MLE")
mi_tbl    <- mi_or    %>% mutate(Model = "MICE pooled")
bayes_tbl <- bayes_or %>% mutate(Model = "Bayesian")

all_tbl <- bind_rows(svy_tbl, mi_tbl, bayes_tbl) %>%
  mutate(term = case_when(
    str_detect(term, "bmi_c|\\bBMI\\b") ~ "BMI (per 1 SD)",
    str_detect(term, "age_c|\\bAge\\b") ~ "Age (per 1 SD)",
    TRUE ~ term
  )) %>%
  filter(term %in% c("BMI (per 1 SD)", "Age (per 1 SD)")) %>%
  mutate(OR_CI = fmt_or(OR, LCL, UCL, digits = 2)) %>%
  select(Model, term, OR_CI) %>%
  arrange(
    factor(Model, levels = c("Survey-weighted MLE","MICE pooled","Bayesian")),
    factor(term,  levels = c("BMI (per 1 SD)","Age (per 1 SD)"))
  )

res_wide <- all_tbl %>%
  pivot_wider(names_from = term, values_from = OR_CI) %>%
  rename(
    `BMI (per 1 SD) OR (95% CI)` = `BMI (per 1 SD)`,
    `Age (per 1 SD) OR (95% CI)` = `Age (per 1 SD)`
  )

kable(
  res_wide,
  align = c("l","c","c"),
  caption = "Odds ratios (per 1 SD) with 95% CIs across models"
)
```

Higher BMI and age were both significantly associated with increased odds of doctor-diagnosed diabetes across all models.  

Results were consistent between frequentist and Bayesian frameworks, with Bayesian credible intervals showing comparable precision.

### Comparative Interpretation

Across all modeling strategies—survey-weighted MLE, multiple imputation (MICE), and Bayesian logistic regression—the associations between age, BMI, sex, and race/ethnicity with doctor-diagnosed diabetes were consistent in magnitude and direction.  

- **Effect stability:** Point estimates from the Bayesian model closely matched those from the frequentist models, suggesting that prior regularization did not distort inference but instead stabilized estimates under modest missingness.  
- **Uncertainty quantification:** Bayesian credible intervals were slightly narrower yet fully overlapped with frequentist confidence intervals, indicating similar inferential precision with improved interpretability.  
- **Design considerations:** While the survey-weighted MLE incorporated NHANES’s complex sampling design directly, the Bayesian model used normalized sampling weights as importance weights—approximating design effects rather than modeling them fully. Therefore, Bayesian results are best interpreted as model-based rather than population-weighted estimates.  

Overall, the Bayesian approach yielded inference that was comparably accurate, more transparent about uncertainty, and less sensitive to small-sample variability.

### Discussion and Conclusion

This analysis examined whether Bayesian logistic regression offers more stable and interpretable inference than classical logistic regression when modeling diabetes risk factors using NHANES 2013–2014 data. All methods—frequentist, imputed, and Bayesian—identified **age** and **BMI** as the strongest predictors of doctor-diagnosed diabetes, with **higher odds among older adults and those with higher BMI.** Females consistently showed lower odds of diabetes than males, while **Mexican American, non-Hispanic Black, and multiracial adults** exhibited elevated odds compared to non-Hispanic Whites.  

The Bayesian approach provided several advantages. By integrating weakly informative priors, it produced regularized parameter estimates that avoided instability under missing data or quasi-separation. Its posterior distributions offered richer insight into uncertainty than single-point frequentist estimates. In contrast, traditional MLE and even multiple imputation can yield biased or overly confident estimates in small or incomplete samples.  

Although the Bayesian model approximated survey weighting rather than fully modeling NHANES’s complex design, the resulting estimates aligned closely with design-based frequentist results, supporting its robustness. The high effective sample sizes and R̂ ≈ 1.00 across parameters confirmed excellent model convergence.  

**In conclusion,** Bayesian logistic regression provided inference that was **statistically consistent, computationally stable, and interpretable**—achieving the aim of this project. Its flexibility and transparency make it a valuable complement to classical regression in epidemiologic research, particularly when data are incomplete or model assumptions are strained. Future work could extend this approach to hierarchical NHANES cycles or include biomarkers to assess nonlinear effects of metabolic risk factors.

## References
