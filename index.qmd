---
title: "Bayesian Logistic Regression for Predicting Diabetes Risk Using NHANES 2013–2014 Data"
subtitle: "A Capstone Project on Bayesian Applications in Epidemiologic Modeling"
author:
  - "Namita Mishra"
  - "Autumn Wilcox"
advisor: "Dr. Ashraf Cohen"
date: '`r Sys.Date()`'
course: Capstone Projects in Data Science

execute:
  echo: false       # Hide all code by default
  warning: false
  message: false
  
format:
  html:
    code-fold: true # Allow readers to expand code if they want

bibliography: references.bib
reference-section-title: "References"
link-citations: true
self-contained: true

editor:
  markdown:
    wrap: 72
---

```{r}
#| label: Libraries
#| include: false

# Install
need <- c(
  "nhanesA","dplyr","readr","DataExplorer","forcats","survey",
  "mice","brms","posterior","broom","ggplot2","stringr","tidyr","knitr",
  "bayesplot","tibble","reshape2","loo"   # <- add loo here
)
for (p in need) if (!requireNamespace(p, quietly = TRUE)) install.packages(p)

# Project Libraries
library(dplyr); library(readr); library(DataExplorer); library(forcats)
library(survey); library(mice); library(brms); library(posterior); library(broom)
library(ggplot2); library(stringr); library(tidyr); library(knitr)
library(bayesplot); library(tibble); library(reshape2)
library(loo)  # <- add this

# Set cmdstanr backend

options(brms.backend = "cmdstanr")

# Optional: confirm CmdStanR is working
if (requireNamespace("cmdstanr", quietly = TRUE)) {
  try(cmdstanr::cmdstan_version(), silent = TRUE)
}
```

Slides: [slides.html](slides.html){target="_blank"} (Edit `slides.qmd`.)

# Introduction

Diabetes mellitus (DM) remains a major public health challenge, and
identifying key risk factors—such as obesity, age, sex, and
race/ethnicity—is essential for prevention and targeted intervention.
Logistic regression is widely used to estimate associations between such
factors and binary outcomes like diabetes diagnosis. However, classical
maximum likelihood estimation (MLE) can produce unstable estimates in
the presence of missing data, quasi-separation, or small samples.
Bayesian logistic regression offers a robust alternative by integrating
prior information, regularizing estimates, and quantifying uncertainty
more transparently than frequentist approaches.

This study applies Bayesian logistic regression to estimate the risk of
doctor-diagnosed diabetes among adults in the 2013–2014 National Health
and Nutrition Examination Survey (NHANES). Predictors include age, body
mass index (BMI), sex, and a coarsened race/ethnicity factor (race3)
comprising White, Black, and Hispanic groups, with low-frequency levels
combined as “Other.” Three analytic frameworks were compared: (1)
survey-weighted maximum likelihood estimation (MLE) using the NHANES
complex design, (2) multiple imputation (MICE) with predictive mean
matching and Rubin’s rules, and (3) Bayesian inference with weakly
informative priors $N(0, 2.5)$ implemented via `brms`. The Bayesian
model incorporated normalized NHANES exam weights as importance weights,
approximating design-based inference. Across all methods, age and BMI
were positively associated with diabetes odds, female sex tended to have
lower odds than male, and Black and Hispanic adults showed higher odds
relative to White. Agreement across modeling frameworks supports the
robustness of these associations and highlights the interpretability and
uncertainty quantification advantages offered by Bayesian analysis for
population health modeling.

Bayesian hierarchical models, implemented via Markov Chain Monte Carlo
(MCMC), have been successfully applied in predicting patient health
status across diseases such as pneumonia, prostate cancer, and mental
disorders [@zeger2020]. By representing predictive uncertainty alongside
point estimates, Bayesian inference offers a practical advantage in
epidemiologic modeling where decisions hinge on probabilistic
thresholds. Beyond stability, Bayesian methods support model checking,
variable selection, and uncertainty quantification under missingness or
imputation frameworks [@baldwin2017; @kruschke2017].

Recent work has expanded Bayesian applications to disease diagnostics
and health risk modeling. For instance, Bayesian approaches have been
used to evaluate NHANES diagnostic data [@chatzimichail2023], to model
cardiovascular and metabolic risk [@liu2013], and to integrate multiple
data modalities such as imaging and laboratory measures
[@abdullah2022bdlhealth]. Moreover, multiple imputation combined with
Bayesian modeling generates robust estimates when data are missing at
random (MAR) or not at random (MNAR) [@austin2021].

The broader Bayesian literature emphasizes the role of priors and model
checking. Weakly informative priors, such as $N(0, 2.5)$ for
coefficients, regularize estimation and reduce variance in small samples
[@gelman2008; @vandeschoot2021]. Tutorials using R packages like `brms`
and `blavaan` illustrate how MCMC enables posterior inference and
empirical Bayes analysis [@klauenberg2015].

Beyond standard generalized linear models, Bayesian nonparametric
regression flexibly captures nonlinearity and zero inflation common in
health data [@richardson2018bnr]. Bayesian Additive Regression Trees
(BART) improve variable selection in mixed-type data [@luo2024bartvs],
while state-space and dynamic Bayesian models incorporate time-varying
biomarkers for longitudinal prediction [@momeni2021covidbayes]. Bayesian
model averaging (BMA) further addresses model uncertainty by weighting
across multiple specifications [@hoeting1999bma]. Together, these
approaches demonstrate the versatility and growing importance of
Bayesian inference in clinical and epidemiologic modeling.

The objective of this project is to evaluate whether Bayesian inference
provides more stable and interpretable estimates of diabetes risk than
frequentist and imputation-based approaches, particularly when data
complexity or separation challenges arise. Agreement across modeling
frameworks supports the robustness of these associations and highlights
the interpretability and uncertainty quantification advantages offered
by Bayesian analysis in population health modeling [@nchs2014].

The analytical framework for this study is grounded in Bayesian logistic
regression, providing a probabilistic approach for estimating diabetes
risk and quantifying uncertainty in population health modeling.

# Method

## Bayesian Logistic Regression

This study employs Bayesian logistic regression to estimate the
association between predictors and a binary outcome.

The Bayesian framework integrates prior knowledge with observed data to
generate posterior distributions, allowing direct probabilistic
interpretation of model parameters.

Unlike traditional frequentist approaches that yield single-point
estimates and p-values, Bayesian methods represent parameters as random
variables with full probability distributions.

This provides greater flexibility, incorporates parameter uncertainty,
and produces credible intervals that directly quantify the probability
that a parameter lies within a given range.

## Model Structure

Bayesian logistic regression models the log-odds of a binary outcome as
a linear combination of predictors:

$$
\text{logit}(P(Y = 1)) = \beta_0 + \beta_1 X_1 + \beta_2 X_2 + \dots + \beta_k X_k
$$

where

-   $P(Y = 1)$ is the probability of the event of interest,
-   $\beta_0$ is the intercept (log-odds when all predictors are zero),
    and
-   $\beta_j$ represents the effect of predictor $X_j$ on the log-odds
    of the outcome, holding other predictors constant.

In the Bayesian framework, the coefficients ($\boldsymbol{\beta}$) are
assigned prior distributions that reflect existing knowledge or
plausible ranges before observing the data.\
After incorporating the observed evidence, the priors are updated
through Bayes’ theorem:

$$
\text{Posterior} \propto \text{Likelihood} \times \text{Prior}
$$

-   **Likelihood:** the probability of the observed data given model
    parameters (as in classical regression).\
-   **Prior:** expresses beliefs or information about parameter values
    before observing data.\
-   **Posterior:** represents updated beliefs about parameter values
    after observing data.

This formulation allows uncertainty to be naturally propagated through
the model, producing full posterior distributions for each coefficient.

## Prior Specification

Weakly informative priors were used to regularize estimation without
imposing strong assumptions:

-   **Regression coefficients:** $N(0, 2.5)$, providing gentle
    regularization while allowing substantial variation in plausible
    effects [@vandeschoot2021].\
-   **Intercept:** Student’s t-distribution prior, $t(3, 0, 10)$, which
    has
    -   3 degrees of freedom (heavy tails to allow occasional large
        effects),\
    -   mean 0 (no bias toward positive or negative effects), and\
    -   scale 10 (broad range of possible values).

Such priors stabilize estimation in the presence of multicollinearity,
limited sample size, or potential outliers.

## Advantages of Bayesian Logistic Regression

-   **Uncertainty quantification:** Produces full posterior
    distributions instead of single estimates.\
-   **Credible intervals:** Provide the range within which a parameter
    lies with a specified probability (e.g., 95%).\
-   **Flexible priors:** Allow integration of expert knowledge or
    findings from prior studies.\
-   **Probabilistic predictions:** Posterior predictive distributions
    yield direct probabilities for new or future observations.\
-   **Model evaluation:** Posterior predictive checks (PPCs) assess how
    well simulated outcomes reproduce observed data.

## Posterior Predictions

Posterior distributions of regression coefficients were used to estimate
the probability of the outcome for given predictor values.\
This allows statements such as:\
\> “Given the predictors, the probability of the outcome lies between X%
and Y%.”

Posterior predictions account for two key sources of uncertainty:

1.  **Parameter uncertainty:** Variability in estimated model
    coefficients.\
2.  **Predictive uncertainty:** Variability in possible future outcomes
    given those parameters.

In Bayesian analysis, all unknown quantities—coefficients, means,
variances, or probabilities—are treated as random variables described by
their posterior distributions.

## Model Evaluation and Diagnostics

Model quality and convergence were assessed using standard Bayesian
diagnostics:

-   **Posterior sampling:** Conducted via Markov Chain Monte
    Carlo (MCMC) using the No-U-Turn Sampler (NUTS), a variant of
    Hamiltonian Monte Carlo (HMC) [@austin2021]. Four chains were run
    with sufficient warm-up iterations to ensure convergence.\
-   **Convergence metrics:** The potential scale reduction factor
    ($\hat{R}$) and effective sample size (ESS) were used to verify
    stability and mixing across chains.\
-   **Autocorrelation checks:** Ensured independence between successive
    draws.\
-   **Posterior predictive checks (PPCs):** Compared simulated outcomes
    to observed data to evaluate fit.\
-   **Bayesian** $R^2$: Quantified the proportion of variance explained
    by predictors, incorporating posterior uncertainty.

# Analysis and Results

## Data Preparation

We analyzed NHANES 2013–2014 public-use data from the CDC’s National
Center for Health Statistics [@nchs2014]. Three component files were
merged: demographics (**DEMO_H**), body measures (**BMX_H**), and the
diabetes questionnaire (**DIQ_H**). All variables were coerced to
consistent numeric or factor types prior to merging to ensure atomic
columns suitable for survey analysis and modeling.

### Import and Merge Datasets

```{r}
#| label: load-merged
#| echo: false
#| message: false
#| warning: false

merged_data <- readRDS("data/merged_2013_2014.rds")

# A compact preview with ONLY analysis variables (no design vars here)
merged_preview <- merged_data %>%
  transmute(
    RIDAGEYR,           # age (raw; will become age / age_c later)
    BMXBMI,             # BMI  (raw; will become bmi / bmi_c later)
    RIAGENDR,           # sex (source)
    RIDRETH1,           # race (source)
    DIQ010              # diabetes indicator (source)
  )

knitr::kable(
  head(merged_preview, 10),
  caption = "Preview of merged NHANES 2013–2014 dataset limited to analysis variables (source columns only)."
)
```

```{r}
#| label: merged-n
#| echo: false
#| include: false
merged_n <- nrow(merged_data)
```

This preview shows the raw NHANES columns before transformation. Each
variable is retained for later use in analysis and renamed or
standardized as appropriate.

The merged dataset contains `r format(merged_n, big.mark = ",")`
participants. It integrates demographic, examination, and
diabetes questionnaire data. We then restrict the sample to **adults (age ≥ 20)** to define the analytic cohort used in subsequent analyses. A small proportion of records have missing values in **BMI** and **diabetes status**, which will be addressed later through multiple imputation.

### Adult Cohort Definition

```{r}
#| label: tbl-variable-descriptions
#| tbl-cap: "Variable Descriptions: Adult Analytic Dataset (NHANES 2013–2014)"
#| echo: false

var_desc <- data.frame(
Variable = c("age", "bmi", "sex", "race3", "diabetes_ind"),
NHANES_Source = c("RIDAGEYR", "BMXBMI", "RIAGENDR", "RIDRETH1", "DIQ010"),
Description = c(
"Participant age in years (adults aged 20 years and older)",
"Body Mass Index (BMI, kg/m²) measured during examination",
"Sex of participant (Male or Female)",
"Race/ethnicity collapsed into White, Black, Hispanic, and Other/Multi categories",
"Doctor-diagnosed diabetes indicator (1 = Yes, 0 = No)"
),
Type = c("Continuous", "Continuous", "Categorical", "Categorical", "Binary")
)

knitr::kable(var_desc, align = "l")
```

```{r}
#| label: adult-eda
#| echo: false
#| include: false
#| message: false
#| warning: false
# Keep NAs (no droplevels, no NA filtering); make NA an explicit level for factors
adult_eda <- merged_data %>%
  dplyr::filter(RIDAGEYR >= 20) %>%
  dplyr::transmute(
    SDMVPSU, SDMVSTRA, WTMEC2YR,
    diabetes_ind = dplyr::case_when(DIQ010 == 1 ~ 1,
                                    DIQ010 == 2 ~ 0,
                                    TRUE ~ NA_real_),
    bmi  = suppressWarnings(as.numeric(BMXBMI)),
    age  = suppressWarnings(as.numeric(RIDAGEYR)),
    sex  = dplyr::case_when(RIAGENDR == 1 ~ "Male",
                            RIAGENDR == 2 ~ "Female",
                            TRUE ~ NA_character_),
    race = dplyr::case_when(
      RIDRETH1 == 1 ~ "Mexican American",
      RIDRETH1 == 2 ~ "Other Hispanic",
      RIDRETH1 == 3 ~ "NH White",
      RIDRETH1 == 4 ~ "NH Black",
      RIDRETH1 == 5 ~ "Other/Multi",
      TRUE ~ NA_character_
    )
  ) %>%
  dplyr::mutate(
    age_c = as.numeric(scale(age)),
    bmi_c = as.numeric(scale(bmi)),
    race3 = forcats::fct_collapse(
              factor(race),
              White    = "NH White",
              Black    = "NH Black",
              Hispanic = c("Mexican American","Other Hispanic"),
              Other    = "Other/Multi"
            ) |>
            forcats::fct_relevel("White") |>
            forcats::fct_explicit_na(na_level = "(Missing)"),
    sex   = factor(sex, levels = c("Male","Female")) |>
            forcats::fct_explicit_na(na_level = "(Missing)")
  )
```

```{r}
#| label: missing-checks
#| echo: false
#| include: false
#| message: false
#| warning: false

# How many NAs in each column?
colSums(is.na(adult_eda))

# Focus on the key variables we expect NAs in
sapply(adult_eda[, c("diabetes_ind","bmi","bmi_c","age")], function(x) sum(is.na(x)))

# Do the source columns actually contain NAs / non-(1,2) codes?
table(merged_data$DIQ010, useNA = "ifany")
sum(is.na(merged_data$BMXBMI))
```

```{r}
#| label: miss-pcts-print
#| echo: false
#| include: false
miss_bmi <- mean(is.na(adult_eda$bmi)) * 100
miss_diab <- mean(is.na(adult_eda$diabetes_ind)) * 100
sprintf("Missing BMI: %.1f%%; Missing diabetes_ind: %.1f%%", miss_bmi, miss_diab)
```

These summaries confirm that only BMI and diabetes indicators contain
missing values, supporting the need for multiple imputation while
keeping other variables complete.

```{r}
#| label: adult-cohort
#| echo: false
#| include: false
#| message: false
#| warning: false

# Define adult analytic cohort (age >= 20)
adult <- merged_data %>%
  filter(RIDAGEYR >= 20) %>%
  transmute(
    SDMVPSU, SDMVSTRA, WTMEC2YR,
    diabetes_ind = case_when(DIQ010 == 1 ~ 1, DIQ010 == 2 ~ 0, TRUE ~ NA_real_),
    bmi = as.numeric(BMXBMI),
    age = as.numeric(RIDAGEYR),
    sex = factor(case_when(
      RIAGENDR == 1 ~ "Male",
      RIAGENDR == 2 ~ "Female"
    )),
    race = factor(case_when(
      RIDRETH1 == 1 ~ "Mexican American",
      RIDRETH1 == 2 ~ "Other Hispanic",
      RIDRETH1 == 3 ~ "NH White",
      RIDRETH1 == 4 ~ "NH Black",
      RIDRETH1 == 5 ~ "Other/Multi"
    ))
  ) %>%
  mutate(
    age_c = scale(age),
    bmi_c = scale(bmi),
    race3 = forcats::fct_collapse(
      race,
      White = "NH White",
      Black = "NH Black",
      Hispanic = c("Mexican American", "Other Hispanic"),
      Other = "Other/Multi"
    ) |> forcats::fct_relevel("White")
  ) %>%
  droplevels()
```

```{r}
#| label: tbl1-analytic
#| echo: false
#| message: false
#| warning: false
#| tbl-cap: "Table 1. Analytic variables for the NHANES 2013–2014 adult cohort (age ≥ 20). Design variables (WTMEC2YR, SDMVPSU, SDMVSTRA) are excluded from this table."

# Keep only analytic variables for Table 1
tbl1_dat <- adult %>%
  transmute(
    age,
    bmi,
    sex,
    race3,
    # CHANGE: make diabetes_ind a factor so it plays nice with pivot_longer()
    diabetes_ind = factor(diabetes_ind, levels = c(0, 1), labels = c("No", "Yes"))
  )

# Continuous summaries: n, missing, mean, sd, min, max
cont_vars <- c("age", "bmi")

cont_sum <- tbl1_dat %>%
  select(all_of(cont_vars)) %>%
  pivot_longer(everything(), names_to = "Variable", values_to = "value") %>%
  group_by(Variable) %>%
  summarise(
    N          = sum(!is.na(value)),
    Missing    = sum(is.na(value)),
    Mean       = mean(value, na.rm = TRUE),
    SD         = sd(value, na.rm = TRUE),
    Min        = min(value, na.rm = TRUE),
    Max        = max(value, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  mutate(across(c(Mean, SD, Min, Max), ~round(.x, 2)))

# Categorical summaries: counts and percents
cat_vars <- c("sex", "race3", "diabetes_ind")

cat_sum <- tbl1_dat %>%
  # CHANGE: ensure all cat vars are factors and include NA as an explicit "(Missing)" level
  mutate(across(all_of(cat_vars),
                ~ forcats::fct_explicit_na(as.factor(.x), na_level = "(Missing)"))) %>%
  select(all_of(cat_vars)) %>%
  pivot_longer(everything(), names_to = "Variable", values_to = "Level") %>%
  count(Variable, Level, name = "n") %>%
  group_by(Variable) %>%
  mutate(pct = round(100 * n / sum(n), 1)) %>%
  ungroup() %>%
  arrange(Variable, desc(n))

kable(cont_sum, caption = "Table 1a. Continuous variables (age, BMI): N, missing, mean (SD), range.")
kable(cat_sum,  caption = "Table 1b. Categorical variables (sex, race3, diabetes_ind): counts and percentages.")
```

```{r}
#| label: adult-n
#| echo: false
#| include: false
adult_n <- nrow(adult)
```

```{r}
#| label: tbl-adult
#| tbl-cap: !expr sprintf("Excerpt of the NHANES 2013–2014 adult cohort (age ≥ 20; N = %s) with derived and standardized variables.", format(adult_n, big.mark = ","))
knitr::kable(head(adult))
```

As shown in @tbl-adult, the analytic adult cohort (N =
`r format(adult_n, big.mark=",")`) includes standardized variables for
age and BMI (`age_c`, `bmi_c`), categorical indicators for sex and
race/ethnicity (`race3`), and a binary doctor-diagnosed diabetes
variable (`diabetes_ind`).

### Missing Data Summary

```{r}
#| label: miss-pcts
#| echo: false
miss_bmi  <- mean(is.na(adult_eda$bmi)) * 100
miss_diab <- mean(is.na(adult_eda$diabetes_ind)) * 100
```

```{r}
#| label: fig-missing
#| fig-cap: "Missing data pattern for analytic variables (outcome and predictors only)."
#| echo: false
DataExplorer::plot_missing(
  adult_eda[, c("diabetes_ind", "bmi", "age")]
)
```

The missingness plot visually confirms that BMI and diabetes status have
modest proportions of missing data, with no evident systematic pattern
across records.

The following histograms and bar charts describe the adult analytic
cohort. Most participants are middle-aged, with a normal-to-overweight
BMI distribution and majority White race composition. This visualization
helps contextualize the predictors used in the models.

```{r}
#| label: fig-cohort-age
#| fig-cap: "Age distribution (age ≥ 20)."
#| echo: false
ggplot(adult_eda, aes(x = age)) +
  geom_histogram(binwidth = 5) +
  labs(x = "Age (years)", y = "Count") +
  theme_minimal()
```

```{r}
#| label: fig-cohort-bmi
#| fig-cap: "BMI distribution."
#| echo: false
ggplot(adult_eda, aes(x = bmi)) +
  geom_histogram(binwidth = 1) +
  labs(x = "BMI (kg/m²)", y = "Count") +
  theme_minimal()
```

```{r}
#| label: fig-cohort-sex
#| fig-cap: "Sex composition."
#| echo: false
adult_eda %>%
  count(sex) %>%
  ggplot(aes(x = sex, y = n)) +
  geom_col() +
  labs(x = NULL, y = "Count") +
  theme_minimal()
```

```{r}
#| label: fig-cohort-race
#| fig-cap: "Race/ethnicity composition (race3)."
#| echo: false
adult_eda %>%
  count(race3) %>%
  ggplot(aes(x = race3, y = n)) +
  geom_col() +
  labs(x = NULL, y = "Count") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 30, hjust = 1))
```

The EDA missingness summary shows approximately
`r sprintf("%.1f", miss_bmi)`% **missing BMI** and
`r sprintf("%.1f", miss_diab)`% **missing diabetes status**
(`diabetes_ind`). All design variables (WTMEC2YR, SDMVPSU, SDMVSTRA), as
well as age, sex, and race3, are complete—sex and race NAs are encoded
as explicit “(Missing)” levels in the EDA view.

These low missingness rates support the use of **multiple imputation
(MICE)** to preserve the analytic sample and reduce bias associated with
listwise deletion.

## Modeling Frameworks

We evaluated three complementary modeling frameworks:\
(1) a **survey-weighted logistic regression** to account for NHANES
design elements,\
(2) **multiple imputation (MICE)** to address missing data, and\
(3) a **Bayesian logistic regression** using weakly informative priors.\
Each model used the same outcome (`diabetes_ind`) and predictors
(standardized age, standardized BMI, sex, and race3).

### Survey-Weighted Logistic Regression (Design-Based MLE)

```{r}
#| label: data-clean
#| echo: false
#| message: false
#| warning: false
#| include: false

adult_clean <- adult %>%
  dplyr::mutate(
    sex   = forcats::fct_drop(sex),
    race3 = forcats::fct_drop(race3),
    age_c = as.numeric(age_c),
    bmi_c = as.numeric(bmi_c)
  ) %>%
  dplyr::filter(!is.na(diabetes_ind), !is.na(age_c), !is.na(bmi_c)) %>%
  droplevels()

str(adult_clean[, c("diabetes_ind","sex","race3","age_c","bmi_c")])
```

```{r}
#| label: model-survey
#| echo: false
#| include: false
#| message: false
#| warning: false

options(survey.lonely.psu = "adjust")

nhanes_design_adult <- survey::svydesign(
id = ~SDMVPSU,
strata = ~SDMVSTRA,
weights = ~WTMEC2YR,
nest = TRUE,
data = adult_clean
)

des_cc <- subset(nhanes_design_adult, !is.na(diabetes_ind) &
!is.na(age_c) & !is.na(bmi_c) &
!is.na(sex) & !is.na(race3))

# Sanity checks before modeling
stopifnot(nlevels(adult_clean$sex)   >= 2)
stopifnot(nlevels(adult_clean$race3) >= 2)

table(adult_clean$sex)
table(adult_clean$race3)

svy_fit <- survey::svyglm(
diabetes_ind ~ age_c + bmi_c + sex + race3,
design = des_cc,
family = quasibinomial()
)

svy_or <- broom::tidy(svy_fit, conf.int = TRUE) %>%
dplyr::mutate(
OR = exp(estimate),
LCL = exp(conf.low),
UCL = exp(conf.high)
) %>%
dplyr::select(term, OR, LCL, UCL, p.value) %>%
dplyr::filter(term != "(Intercept)")
```

```{r}
#| label: tbl-survey
#| echo: false
#| tbl-cap: "Survey-weighted logistic regression: odds ratios (OR) and 95% confidence intervals for diabetes diagnosis among adults (NHANES 2013–2014)."
knitr::kable(svy_or)
```

The design-based model accounts for NHANES sampling weights and
clustering. Positive coefficients for age and BMI indicate higher
diabetes odds per one-SD increase, while categorical contrasts show
elevated odds among non-White groups.

The NHANES 2013–2014 data use a complex, multistage probability design
involving **strata** (`SDMVSTRA`), **primary sampling units (PSUs;
SDMVPSU)**, and **examination weights (`WTMEC2YR`)** to ensure
nationally representative estimates [@nchs2014].

This model incorporates those design elements via the `svydesign()`
function to produce population-weighted logistic regression estimates
that reflect the U.S. civilian, noninstitutionalized population.

Odds ratios are expressed per one standard deviation (SD) increase in
**age** and **BMI**, quantifying the association between each predictor
and the probability of a doctor-diagnosed diabetes outcome.

Notes: Reference categories are **Male** for sex and **White** for
race3. **Age** and **BMI** odds ratios are reported per one standard
deviation (1 SD) increase.

### Multiple Imputation (MICE)

```{r}
#| label: model-mice
#| echo: false
#| include: false
#| message: false
#| warning: false

# Build data for imputation

mi_dat <- adult %>%
dplyr::select(diabetes_ind, age, bmi, sex, race3, WTMEC2YR, SDMVPSU, SDMVSTRA)

# Specify methods and predictor matrix

meth <- mice::make.method(mi_dat)
pred <- mice::make.predictorMatrix(mi_dat)

# Outcome not imputed; used as predictor only

meth["diabetes_ind"] <- ""
pred["diabetes_ind", ] <- 0
pred[, "diabetes_ind"] <- 1

# Continuous vars: age = normal; bmi = predictive mean matching (PMM).
# Categoricals: sex = logistic; race3 = polytomous regression.

meth[c("age","bmi")]   <- c("norm","pmm")
meth[c("sex","race3")] <- c("logreg","polyreg")

# Design variables as auxiliaries only

meth[c("WTMEC2YR","SDMVPSU","SDMVSTRA")] <- ""
pred[, c("WTMEC2YR","SDMVPSU","SDMVSTRA")] <- 1

# Run imputation

imp <- mice::mice(mi_dat, m = 20, method = meth, predictorMatrix = pred, seed = 123)

# Fit logistic regression within each imputed dataset

fits <- with(
  imp,
  glm(
    diabetes_ind ~ scale(age) + scale(bmi) + relevel(sex, "Male") + relevel(race3, "White"),
    family = binomial()
  )
)

# Pool estimates across imputations

pool_mi <- mice::pool(fits)

mi_or <- summary(pool_mi, conf.int = TRUE, exponentiate = TRUE) %>%
dplyr::rename(OR = estimate, LCL = `2.5 %`, UCL = `97.5 %`) %>%
dplyr::filter(term != "(Intercept)")
```

Multiple imputation preserves sample size and reduces bias from missing
BMI values. Results closely mirror the survey-weighted model, confirming
robustness to imputation.

```{r}
#| label: tbl-mice
#| echo: false 
miss_age  <- sum(is.na(mi_dat$age))
miss_bmiN <- sum(is.na(mi_dat$bmi))

mi_caption <- if (miss_age > 0 && miss_bmiN > 0) {
  "Multiple Imputation (MICE): pooled odds ratios (OR) and 95% confidence intervals after imputing missing age (normal) and BMI (PMM) (m = 20); diabetes status was not imputed."
} else if (miss_bmiN > 0) {
  "Multiple Imputation (MICE): pooled odds ratios (OR) and 95% confidence intervals after imputing missing BMI (PMM) (m = 20); diabetes status was not imputed."
} else if (miss_age > 0) {
  "Multiple Imputation (MICE): pooled odds ratios (OR) and 95% confidence intervals after imputing missing age (normal) (m = 20); diabetes status was not imputed."
} else {
  "Multiple Imputation (MICE): pooled odds ratios (OR) and 95% confidence intervals (no variables required imputation); diabetes status was not imputed."
}
mi_caption <- paste0(mi_caption, " Odds ratios are per 1 SD for age and BMI.")

knitr::kable(mi_or, caption = mi_caption)
```

The multiple imputation (MICE) framework addressed missingness in
**BMI** using predictive mean matching (PMM). **Diabetes status
(`diabetes_ind`) was not imputed** (used as a predictor only).
Categorical variables (`sex`, `race3`) used logistic/polytomous
regression. We generated m = 20 imputations and pooled estimates with
Rubin’s rules. Odds ratios are reported per one standard deviation (1
SD) increase in age and BMI.

### Bayesian Logistic Regression

```{r}
#| label: model-bayesian
#| cache: true
#| echo: false
#| include: false
#| message: false
#| warning: false
#| results: 'hide'

# Prepare a single imputed dataset (from MICE results)

adult_imp1 <- mice::complete(imp, 1) %>%
dplyr::mutate(
sex   = factor(sex,   levels = levels(adult$sex)),
race3 = factor(race3, levels = levels(adult$race3)),
age_c = as.numeric(scale(age)),
bmi_c = as.numeric(scale(bmi)),
wt_norm = WTMEC2YR / mean(WTMEC2YR, na.rm = TRUE)
) %>%
dplyr::filter(!is.na(diabetes_ind), !is.na(age_c), !is.na(bmi_c)) %>%
droplevels()

# Define model formula

fml_bayes <- diabetes_ind | weights(wt_norm) ~ age_c + bmi_c + sex + race3

# Specify weakly informative priors

priors <- c(
brms::set_prior("normal(0, 2.5)", class = "b"),
brms::set_prior("student_t(3, 0, 10)", class = "Intercept")
)

# Fit Bayesian logistic regression

invisible(capture.output({
  bayes_fit <- brms::brm(
    formula = fml_bayes,
    data    = adult_imp1,
    family  = bernoulli(link = "logit"),
    prior   = priors,
    chains  = 4, iter = 2000, seed = 123,
    control = list(adapt_delta = 0.95),
    refresh = 0
  )
}))

# Shared objects for diagnostics/plots
yobs <- adult_imp1$diabetes_ind

# Extract posterior summaries and transform to odds ratios

bayes_or <- brms::posterior_summary(bayes_fit, pars = "^b_") %>%
as.data.frame() %>%
tibble::rownames_to_column("raw") %>%
dplyr::mutate(
term = gsub("^b_", "", raw),
OR   = exp(Estimate),
LCL  = exp(Q2.5),
UCL  = exp(Q97.5)
) %>%
dplyr::select(term, OR, LCL, UCL)
```

```{r}
#| label: tbl-bayes
#| echo: false
#| tbl-cap: "Bayesian logistic regression: posterior odds ratios (OR) with 95% credible intervals for diabetes diagnosis among adults (NHANES 2013–2014)."
knitr::kable(
  dplyr::mutate(bayes_or, dplyr::across(c(OR, LCL, UCL), ~ round(.x, 2)))
)
```

```{r}
#| label: build-bullets
#| echo: false
#| include: false

library(dplyr)
library(glue)

pull_or <- function(df, term) {
  row <- df %>% filter(term == !!term)
  if (nrow(row) == 0) return(list(or=NA, lcl=NA, ucl=NA))
  list(or = row$OR[1], lcl = row$LCL[1], ucl = row$UCL[1])
}
fmt <- function(x) sprintf("%.2f", x)
excludes1 <- function(lcl,ucl) ifelse(!is.na(lcl) && !is.na(ucl) && (lcl>1 | ucl<1), "CrI excludes 1", "CrI overlaps 1")

age  <- pull_or(bayes_or, "age_c")
bmi  <- pull_or(bayes_or, "bmi_c")
fem  <- pull_or(bayes_or, "sexFemale")
blk  <- pull_or(bayes_or, "race3Black")
his  <- pull_or(bayes_or, "race3Hispanic")
oth  <- pull_or(bayes_or, "race3Other")

post <- as.data.frame(brms::as_draws_df(bayes_fit))
b0   <- mean(post$b_Intercept)
baseline_p <- plogis(b0)
baseline_txt <- sprintf("%.1f%%", 100*baseline_p)

bullets <- c(
  "### Population-level interpretation (posterior, odds ratios)",
  " - **Convergence.** All R-hat ≈ 1.00; large ESS → excellent mixing.",   # <- no LaTeX, no escaping issues
  glue(" - **Baseline risk.** Male, White, mean age/BMI: **~{baseline_txt}** predicted diabetes prevalence."),
  glue(" - **Age.** +1 SD → **{fmt(age$or)}×** (95% CrI {fmt(age$lcl)}–{fmt(age$ucl)}; {excludes1(age$lcl,age$ucl)})."),
  glue(" - **BMI.** +1 SD → **{fmt(bmi$or)}×** (95% CrI {fmt(bmi$lcl)}–{fmt(bmi$ucl)}; {excludes1(bmi$lcl,bmi$ucl)})."),
  glue(" - **Female vs Male.** **{fmt(fem$or)}×** (95% CrI {fmt(fem$lcl)}–{fmt(fem$ucl)}; {excludes1(fem$lcl,fem$ucl)})."),
  glue(" - **Black vs White.** **{fmt(blk$or)}×** (95% CrI {fmt(blk$lcl)}–{fmt(blk$ucl)}; {excludes1(blk$lcl,blk$ucl)})."),
  glue(" - **Hispanic vs White.** **{fmt(his$or)}×** (95% CrI {fmt(his$lcl)}–{fmt(his$ucl)}; {excludes1(his$lcl,his$ucl)})."),
  glue(" - **Other/Multi vs White.** **{fmt(oth$or)}×** (95% CrI {fmt(oth$lcl)}–{fmt(oth$ucl)}; {excludes1(oth$lcl,oth$ucl)}).")
)
```

As shown in @tbl-bayes, this Bayesian logistic regression model
estimates the log-odds of diabetes using standardized predictors.\

Weakly informative priors ($N(0, 2.5)$ for slopes; Student-t(3, 0, 10)
for the intercept) help stabilize estimation and prevent overfitting.\

Posterior means and 95% credible intervals (CrI) provide full
uncertainty quantification for each predictor, enabling direct
probabilistic interpretation.

Note: The Bayesian model used normalized NHANES exam weights as
importance weights, approximating design-based inference; strata and
PSUs were not directly modeled.

```{r}
#| label: tbl-bayesR2
#| echo: false
#| tbl-cap: "Bayesian R² summary."
knitr::kable(as.data.frame(brms::bayes_R2(bayes_fit)))
```

```{r}
#| label: tbl-mcmc-diagnostics
#| tbl-cap: "MCMC diagnostics (R-hat and Effective Sample Sizes) for model parameters (including intercept)."
#| echo: false

# Get diagnostics as plain columns (use metric names as strings)
diag <- posterior::summarise_draws(
  bayes_fit,
  "rhat", "ess_bulk", "ess_tail"
)

# Keep only slope parameters (b_*) and build a clean table.
diag_b <- diag |>
  dplyr::as_tibble() |>
  dplyr::filter(grepl("^b_", .data$variable)) |>
  dplyr::transmute(
    Parameter = .data$variable,
    Rhat      = .data$rhat,
    Bulk_ESS  = .data$ess_bulk,
    Tail_ESS  = .data$ess_tail
  )

knitr::kable(diag_b, digits = 1)
```

Bayesian parameter estimates are consistent with frequentist results,
with credible intervals providing direct probability statements.
Diagnostics show good chain mixing ($\hat{R} \approx 1.00$) and
effective sample sizes exceeding standard thresholds, confirming
convergence.

```{r}
#| label: model-comparison
#| tbl-cap: "Bayesian model comparison (LOO): base model vs models without race or without sex."
#| echo: false
#| message: false
#| warning: false

# Reduced models (let brms compile if needed)
invisible(capture.output({
  fit_no_race <- update(bayes_fit, formula = update(fml_bayes, . ~ . - race3))
  fit_no_sex  <- update(bayes_fit, formula = update(fml_bayes, . ~ . - sex))
}))

# Compute LOO for all three models
loo_base    <- loo::loo(bayes_fit)
loo_no_race <- loo::loo(fit_no_race)
loo_no_sex  <- loo::loo(fit_no_sex)

# Compare (pass objects positionally)
cmp <- loo::loo_compare(loo_base, loo_no_race, loo_no_sex)

# Make row names explicit and sort best-to-worst already by loo_compare
cmp_df <- as.data.frame(cmp)
cmp_df$Model <- rownames(cmp_df)
cmp_df <- cmp_df[, c("Model", setdiff(names(cmp_df), "Model"))]

knitr::kable(
  cmp_df,
  caption = "LOO comparison (higher elpd_loo is better; table sorted best to worst)."
)
```

Leave-one-out (LOO) cross-validation indicates that removing race or sex
reduces model fit, confirming that both variables meaningfully
contribute to predictive performance.

```{r}
#| label: fig-mcmc-areas
#| fig-cap: "Posterior distributions (95% credible mass) for slope parameters."
#| echo: false
bayesplot::mcmc_areas(
as.array(bayes_fit),
regex_pars = "^b_",
prob = 0.95
)
```

```{r}
#| label: fig-mcmc-trace
#| fig-cap: "Trace plots for slope parameters (chain mixing and stationarity)."
#| echo: false
bayesplot::mcmc_trace(
as.array(bayes_fit),
regex_pars = "^b_"
)
```

```{r}
#| label: fig-ppc-bars
#| fig-cap: "Posterior predictive check: observed vs replicated outcome distribution (bars)."
#| echo: false

bayesplot::pp_check(bayes_fit, type = "bars", nsamples = 100)
```

```{r}
#| label: fig-ppc-mean-sd
#| fig-cap: "Posterior predictive checks for mean and standard deviation of the binary outcome."
#| echo: false
yrep <- brms::posterior_predict(bayes_fit, ndraws = 400)  # draws x observations

bayesplot::ppc_stat(y = yobs, yrep = yrep, stat = "mean")
bayesplot::ppc_stat(y = yobs, yrep = yrep, stat = "sd")
```

```{r}
#| label: fig-or-forest
#| fig-cap: "Posterior odds ratios (points) with 95% credible intervals (lines)."
#| echo: false

or_plot <- bayes_or %>%
  dplyr::filter(term != "Intercept") %>%
  dplyr::mutate(
    term_clean = dplyr::case_when(
      term == "age_c"            ~ "Age (per 1 SD)",
      term == "bmi_c"            ~ "BMI (per 1 SD)",
      term == "sexFemale"        ~ "Female (vs Male)",
      term == "sexMale"          ~ "Male (vs Female)",
      term == "race3Black"       ~ "Black (vs White)",
      term == "race3Hispanic"    ~ "Hispanic (vs White)",
      term == "race3Other"       ~ "Other (vs White)",
      TRUE                       ~ term
    )
  )

ggplot(or_plot, aes(x = OR, y = reorder(term_clean, OR))) +
  geom_vline(xintercept = 1, linetype = 2) +
  geom_point() +
  geom_errorbarh(aes(xmin = LCL, xmax = UCL), height = 0.15) +
  labs(x = "Odds ratio (logit model, posterior)", y = NULL)
```

```{r}
#| label: fig-pred-calibration
#| fig-cap: "Observed outcome vs mean predicted probability (calibration scatter with smoother)."
#| echo: false
pred_mean <- colMeans(brms::posterior_epred(bayes_fit))
ggplot(data.frame(pred = pred_mean, obs = yobs),
       aes(x = pred, y = obs)) +
  geom_point(alpha = 0.15, position = position_jitter(height = 0.03)) +
  geom_smooth(method = "loess", se = TRUE) +
  labs(x = "Mean predicted probability", y = "Observed diabetes (0/1)")
```

```{r}
#| label: fig-posterior-prevalence
#| fig-cap: "Posterior predictive distribution of diabetes prevalence compared to observed NHANES prevalence."
#| echo: false

post_pred <- brms::posterior_epred(bayes_fit, summary = FALSE)
post_prev <- rowMeans(post_pred)
obs_prev  <- mean(adult_imp1$diabetes_ind, na.rm = TRUE)
post_prev_mat <- matrix(post_prev, ncol = 1, dimnames = list(NULL, "Prevalence"))

p <- bayesplot::mcmc_dens(post_prev_mat)
p + ggplot2::labs(title = "Posterior diabetes prevalence",
                  x = "Predicted prevalence", y = NULL) +
    ggplot2::geom_vline(xintercept = obs_prev, linetype = 2)

p
```

```{r}
#| label: fig-prior-posterior-overlay
#| fig-cap: "Overlay of prior and posterior densities for key predictors (only coefficients present in the model are plotted)."
#| echo: false
# Auto-detect available parameter names and intersect with what we want

# Convert to draws array and get parameter names
draws_arr <- posterior::as_draws_array(bayes_fit)
vars      <- dimnames(draws_arr)$variable

# Build desired coefficient names from your model structure
# Continuous
want <- c("b_age_c", "b_bmi_c")

# Categorical: build names from factor levels with reference dropped
# (Assumes 'Male' and 'White' are references; adjusts automatically if not.)
sex_levels   <- levels(adult_imp1$sex)
race3_levels <- levels(adult_imp1$race3)

if (!is.null(sex_levels) && length(sex_levels) > 1) {
  ref_sex <- sex_levels[1]     # brms uses first level as reference
  others  <- setdiff(sex_levels, ref_sex)
  want <- c(want, paste0("b_sex", others))     # e.g., "b_sexFemale"
}

if (!is.null(race3_levels) && length(race3_levels) > 1) {
  ref_race <- race3_levels[1]  # brms uses first level as reference
  others   <- setdiff(race3_levels, ref_race)
  want <- c(want, paste0("b_race3", others))   # e.g., "b_race3Black"
}

# Keep only those that actually exist in the posterior draws
present <- intersect(want, vars)

# If none found, give a friendly message instead of erroring
if (length(present) == 0) {
  message("No matching b_* coefficients found to plot. Check factor level references and variable names.")
} else {
  bayesplot::mcmc_dens_overlay(
    draws_arr,
    pars = present
  )
}
```

The posterior predictive distribution of diabetes prevalence closely
aligned with the observed NHANES prevalence, suggesting good model
calibration. Priors and posteriors overlapped primarily for weak
predictors, while strong effects (BMI, age, race) showed distinct
posterior shifts, confirming that inference was data-driven rather than
dominated by priors.

## Results

```{r}
#| label: results-bullets
#| echo: false
#| results: 'asis'
cat(paste(bullets, collapse = "\n"))
```

```{r}
#| label: results-compare
#| echo: false
#| message: false
#| warning: false

# Combine results from all three models

svy_tbl   <- if (exists("svy_or") && nrow(svy_or) > 0)
dplyr::mutate(svy_or,   Model = "Survey-weighted (MLE)") else NULL
mi_tbl    <- if (exists("mi_or") && nrow(mi_or) > 0)
dplyr::mutate(mi_or,    Model = "MICE Pooled") else NULL
bayes_tbl <- if (exists("bayes_or") && nrow(bayes_or) > 0)
dplyr::mutate(bayes_or, Model = "Bayesian") %>%
dplyr::filter(term != "Intercept") else NULL

all_tbl <- dplyr::bind_rows(Filter(Negate(is.null), list(svy_tbl, mi_tbl, bayes_tbl))) %>%
dplyr::mutate(
term = dplyr::case_when(
  grepl("^bmi", term,  ignore.case = TRUE) ~ "BMI (per 1 SD)",
  grepl("^age", term,  ignore.case = TRUE) ~ "Age (per 1 SD)",
  grepl("^sexFemale$", term)               ~ "Female (vs Male)",
  grepl("^sexMale$", term)                 ~ "Male (vs Female)",
  grepl("^race3Hispanic$", term)           ~ "Hispanic (vs White)",
  grepl("^race3Black$", term)              ~ "Black (vs White)",
  grepl("^race3Other$", term)              ~ "Other (vs White)",
  TRUE ~ term
),
OR_CI = sprintf("%.2f (%.2f – %.2f)", OR, LCL, UCL)
) %>%
dplyr::select(Model, term, OR_CI)
```

```{r}
#| label: tbl-comparison
#| tbl-cap: "Comparison of odds ratios (per 1 SD for age and BMI) and 95% intervals across survey-weighted, MICE, and Bayesian frameworks."
knitr::kable(all_tbl, align = c("l","l","c"))
```

This table summarizes results from the survey-weighted (design-based),
multiple-imputation, and Bayesian models.\

Across all frameworks, **age** and **BMI** consistently show strong
positive associations with diabetes risk, confirming robustness to
missing-data handling and modeling assumptions.\

The **Bayesian** model’s credible intervals closely align with the
frequentist confidence intervals but provide a more direct probabilistic
interpretation of uncertainty.

## Discussion and Limitations

### Interpretation

The Bayesian logistic regression framework produced results that were
highly consistent with both the survey-weighted and MICE-pooled
frequentist models. Age and BMI remained the most influential predictors
of doctor-diagnosed diabetes, each showing a strong and positive
association with diabetes risk. Posterior credible intervals were
slightly narrower than frequentist confidence intervals, reflecting the
stabilizing influence of weakly informative priors.

Unlike classical maximum likelihood estimation, the Bayesian approach
directly quantified uncertainty through posterior distributions,
offering richer interpretability and more transparent probability
statements. The alignment between Bayesian and design-based estimates
supports the robustness of these associations and highlights the
practicality of Bayesian modeling for complex, weighted population data.
Moreover, the Bayesian framework allowed diagnostic evaluation through
posterior predictive checks and Bayesian R², confirming that model fit
and predictive adequacy were acceptable.

Overall, this study demonstrates how Bayesian inference complements
traditional epidemiologic methods—maintaining interpretability while
improving stability under missing data and modest sample imbalance.

### Limitations

While this analysis demonstrates the value of Bayesian logistic
regression for epidemiologic modeling, several limitations should be
acknowledged.

First, the use of a single imputed dataset for the Bayesian model—rather
than full joint modeling of imputation uncertainty—may understate total
variance.

Second, NHANES exam weights were normalized and treated as importance
weights, which approximate but do not fully reproduce design-based
inference.

Third, the weakly informative priors $N(0, 2.5)$ for slopes and
*Student-t(3, 0, 10)* for the intercept were not empirically tuned;
alternative prior specifications could slightly alter posterior
intervals.

Finally, although convergence diagnostics (R̂ ≈ 1, sufficient effective
sample sizes, and stable posterior predictive checks) indicated good
model performance, results are conditional on the 2013–2014 NHANES cycle
and may not generalize to later datasets or longitudinal analyses.

## Conclusion

The Bayesian, survey-weighted, and imputed logistic regression
frameworks all identified consistent predictors of diabetes risk in U.S.
adults: advancing age, higher BMI, male sex, and non-White
race/ethnicity.

The Bayesian model produced estimates nearly identical in direction and
magnitude to the frequentist results while providing a more
comprehensive assessment of uncertainty through posterior distributions
and credible intervals.

By incorporating prior information and using MCMC to sample from the
full posterior distribution, Bayesian inference enhances model
transparency and interpretability.

Its agreement with traditional approaches underscores that Bayesian
methods can be applied confidently in large-scale public health datasets
such as NHANES.

Future extensions could integrate hierarchical priors, longitudinal
NHANES cycles, or Bayesian model averaging to better capture population
heterogeneity and evolving diabetes risk patterns over time.
